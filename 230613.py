'''
p311. 모험가 길드
모험가가 N명 있을 때, 모험가는 각각 공포를 무서워하는 정도를 가지고 있다.
공포도가 X인 모험가는 반드시 X명 이상으로 구성한 모함가 그룹에 참여해야 한다.
N명의 모험가에 대한 정보가 주어졌을 때 여행을 떠날 수 있는 그룹 수의 최댓값을
구하는 프로그램을 만들어라. 단, 모험가를 모두 그룹에 넣을 필요는 없다.

첫째줄에 모험가의 수 N이 주어진다 (1~100,000)
둘째줄에 모험가의 공포도 값을 N이하의 자연수로 주어지며 각 자연수는 공백으로 구분한다.

입력 예시
5
2 3 1 2 2

출력예시
2

'''

# 풀이과정
# 공포도 높은 숫서대로 정렬하고 공포도 숫자만큼 리스트에서 묶는다. [3, 2, 2, / 2, 1]


# 코딩 
# N = int(input('인원수를 입력하세요'))
# adventurer = list(map(int,input('공포도를 입력하세요').split(' ')))


N = 5
adventurer = list(map(int,'2 3 1 2 2'.split(' ')))
adventurer.sort(reverse=True) # 공포도 높은순 정렬
print(adventurer)

accumulate = 0 # 누적 
team = 0 # 결성된 팀 숫자 

while True :
    accumulate += adventurer[accumulate] 
    # 공포도 높은수만큼 건너뛴다 adventurer[0] 3 -> adventurer[3] 2 -> adventurer[5](없음) 
    team += 1 # 팀이 결성될 때마다 1팀씩 추가한다.  
    if accumulate >= len(adventurer) : # 인원수보다 공포도가 커지면 인원이 모자라니까 종료한다.
        break 
print(team)

  
 


'''
p312 곱하기 혹은 더하기
숫자로 이루어진 문자열 S가 주어졌을 때 숫자 사이에 * 혹은 + 를 넣어 가장 큰 수를 작성하세요.
모든 연산은 왼쪽에서부터 순서대로 이루어진다.
단, 가장 큰 수는 20억 이하의 정수가 된다.

첫째줄에 여러개의 숫자로 구성된 하나의 문자열 S가 주어진다. (1~20)

입력 예시
02984

출력예시
576

입력 예시2
567

출력 예시2
210
'''

# 풀이과정 
# 0일 때만 뎃셈을 해야 하니까, 0을 다 없에버리고 그냥 곱셈.

S = '02984'
sum = 1
for i in S.replace('0','') : # replace로 0을 삭제하고 리스트에서 하나씩 꺼낸다. 
     sum *= int(i) # 누적해서 곱한다. 
print(sum)



''' 
p.313 문자열 뒤집기

0과 1로만 이루어진 문자열 S를 가지고 있을 때 최소한의 뒤집기로 모든 숫자를 같게 뒤집어라
연속된 하나 이상의 숫자를 잡고 모두 뒤집어야 한다.

예시)
S = 0001100
4번째부터 5번째 문자까지 뒤집으면 0000000이 되어 한번만에 모두 같은 숫자가 된다.

첫째줄에 0과 1로만 이루어진 문자열 S가 주어지며 이때 S는 100만보다 작다.

입력예시
0001100

출력예시
1
'''


# 풀이과정 
# 문자를 연속된 0 덩어리와 1 덩어리로 구분한다 (000 / 11 / 000)
# 더 작은 덩어리를 뒤집는다. 

S = '0001100' # 나중에 인풋으로 받을 값

cnt0 = 0 # 0덩어리 모음
cnt1 = 0 # 1덩어리 모음

if S[0] == 0 : # 시작되는 덩어리는 무엇인가? 
    cnt0 += 1 # 0으로 시작되면 0덩어리에 1추가 
else : # 1로 시작되면 
    cnt1 += 1 # 1덩어리에 1추가 

for i in range(len(S)-1) : # 문자 길이만큼 꺼낸다. (out of range 조심)
     if S[i] != S[i+1] : # 앞숫자와 뒷숫자가 다르면 
          if S[i] == 0 : # 앞이 0이고 뒷숫자랑 다르면  
               cnt1 += 1 # 1덩어리의 시작이다 
          else : # 앞이 1인데 뒷숫자랑 다르면 
               cnt0 += 1  # 0덩어리의 시작이다 
print(min(cnt0,cnt1)) # 두 덩어리중 작은 덩어리를 뒤집어라 








